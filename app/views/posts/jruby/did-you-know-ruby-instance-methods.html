*{META
title: 'Did You Know: Ruby Instance Methods'
summary: 'I show off a lesser known feature of Ruby objects: Instance Methods'
tags: Ruby,Meta-Programming
category: journal
brushes: ruby
date: 9/14/2009 12:47
legacyId: 170
META}*

<p>Did you know that in Ruby you can add new methods to a particular object, as opposed to adding them to the entire class?</p>
<p>Ruby makes it easy to re-open any class to add new methods - that's almost always covered early on in Ruby books that talk through using the IRB; it's a great tool for being able to evolve code incrementally as you are scripting the solution. Less common, however is discussion over how to add methods to individual objects; something that feels foreign to a lot of Java developers like myself. It turns out, it's just as easy as adding methods to the class.</p>
<p>For example, let's say you have created a class to represent a dog:</p>

#{code 'ruby'}
class Dog
 def bark
  puts 'Woof!'
 end
end

pug = Dog.new
basset = Dog.new

pug.bark
>> Woof!

basset.bark
>> Woof!
#{/code}

<p>Adding a method to all objects of the class dog is very simple. Simply re-declare the class, defining the new methods in place:</p>

#{code 'ruby'}
class Dog
 def growl
  puts 'Grrr!'
 end
end
#{/code}

<p>To show that this new method works on all instances of that class, we can now call it on both of our existing dog objects:</p>

#{code 'ruby'}
pug.growl
>> Grrr!

basset.growl
>> Grrr!
#{/code}

<p>There can be cases where a particular object should be given special functionality without manipulating all objects of that class; generally speaking this is a case where the object needs to be <a href="http://en.wikipedia.org/wiki/Adapter_pattern">adapted</a>. There are different ways to achieve this, such as using a proxy object wrapping the original; however one way to solve this involves adding the method to just one object. This isn't always the "right" solution for the job, but there are definitely cases where it can streamline a block of code, by simply being able to adapt an existing object to fit a different API.</p>
<p>In Ruby this is done simply by prefacing the method name with the variable name of the object you want to modify (obviously, that object has to be in scope at the time you make the modification). Beyond that, the syntax is the same as any method definition:</p>

#{code 'ruby'}
def pug.snort
 puts 'SNGRRHT!'
end
#{/code}

<p>Note the 'pug.' prefix. The best way to read this is "define the method snort on the object pug, and assign this code block to it". Simple testing will show that our pug now has "snort" behavior, but our basset, on the other hand, does not:</p>

#{code 'ruby'}
pug.snort
>> SNGRRHT!

basset.snort
>> NoMethodError: undefined method `snort' for <Dog:0x1de8aa8>
#{/code}